### 스레드보다는 실행자, 태스크, 스트림을 애용하라



**java.util.concurrent패키지**

이 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다

```java
// 작업 큐 생성
ExecutorService exec = Executors.newSingleThreadExecutor();

// 실행할 태스크 넘기는 방법
exec.execute(runnable);

// 실행자 종료
exec.shutdown();
```

그 외 실행자 서비스의 다양한 주요 기능들이 있다

- 특정 태스크가 완료되기를 기다린다
- 태스크 모음 중 아무것 하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다
- 실행자 서비스가 종료하기를 기다린다(awaitTermination 메서드)
- 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용)
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 된다(ScheduledThreadPoolExecutor 이용)

<br>

**큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다**

스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수 있다

`Java.util.concurrent.Executors` 의 정적 팩터리들을 이용해 생성할 수 있다

평범하지 않은 실행자를 원한다면 `ThreadPoolExecutor` 클래스를 직접 사용해도 된다

>  이 클래스로는 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다

<br>

**실행자 서비스를 사용하기 까다로운 애플리케이션**

작은 프로그램이나 가벼운 서버라면 특별히 설정할 게 없고 일반적인 용도에 적합한 `Executors.newCachedThreadPool` 를 사용한다

> `CachedThreadPool`에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임하여 실행한다
>
> 가용한 스레드가 없다면 새로 하나를 생성한다
>
> 서버가 아주 무겁다면 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 새로운 스레드를 생성하며 더욱 악화시킨다

무거운 프로덕션 서버에서는 스레드 개수를 고정한 `Executors.newFixedThreadPool`을 선택하거나 완전히 통제할 수 있는 `ThreadPoolExecutor`를 직접 사용하는 편이 훨씬 낫다

<br>

**작업 큐를 손수만들거나 스레드를 직접 다루는것은 일반적으로 삼가야 한다**

스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 되지만 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다

작업 단위를 나타내는 핵심 추상 개념인 태스크에는 `Runnable`과 그 사촌인 `Callable` 두 가지가 있고, 이를 수행하는 일반적인 메커니즘이 바로 실행자 서비스다 

> `Callable`은 `Runnable`과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다

태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다

핵심은 (컬렉션 프레임워크가 데이터 모음을 담당하듯) 실행자 프레임워크가 작업 수행을 담당해준다는 것이다

<br>

**포크-조인 태스크** *(자바7부터 지원)*

포크-조인 태스크, 즉 `ForkJoinTask`의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다
