Effective Java의 스물여섯 번째 아이템 "로 타입은 사용하지 말라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 1. 로 타입

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 **제네릭 클래스** 혹은 **제네릭 인터페이스**라 하며 통틀어 제네릭 타입이라 한다. 각각의 제네릭 타입은 일련의 **매개변수화 타입**을 정의한다. 먼저 클래스 이름이 나오고, 이어서 꺽쇠괄호 안에 실제 타입 매개변수들을 나열한다.

제네릭 타입을 하나 정의하면 그에 딸린 **로 타입(raw type)**도 함께 정의된다. 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 예를 들어 List\<E\>의 로 타입은 List다.

<br>

### 1) 문제점

로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.

 제네릭을 지원하기 전에는 컬렉션을 다음과 같이 선언했다.

```java
// Stamp 인스턴스만 취급한다.
private final Collection stamps = ...;
```

이 코드를 사용하면 실수로 Stamp 대신 Coin을 넣어도 아무 오류 없이 컴파일되고 실행된다.

```java
stamps.add(new Coin(...));
```

컬렉션에서 이 Coin을 다시 꺼내기 전에는 오류를 알아채지 못한다.

```java
for (Iterator i = stamps.iterator(); i.hasNext(); ) {
  Stamp stamp = (Stamp) i.next(); // ClassCastException을 던진다.
  stamp.cancel();
}
```

<br>

### 2) 제네릭 활용

제네릭을 활용하면 "Stamp 인스턴스만 취급한다."는 정보가 타입 선언 자체에 녹아든다.

```java
private final Collection<Stamp> stamps = ...;
```

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다. 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장한다.

<br>

### 3) 로 타입의 존재 이유

앞에서도 얘기했듯, 로 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다. 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.

그렇다면 로 타입을 애초에 왜 만들어놓은 걸까? 

바로 호환성 때문이다. 자바가 제네릭을 받아들이기까지 오랜시간이 흘렀다. 따라서 기존 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했다. 이 마이그레이션 호환성을 위해 로 타입을 지원하고 제네릭 구현에는 소거 방식을 사용하기로 했다.

<br>

## 2. 매개변수화 타입

List 같은 로 타입은 사용해서는 안 되나, List\<Object\>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다. 

List와 List\<Object\>의 차이는 무엇일까?

List는 제네릭 타입에서 완전히 발을 뺀 것이고, List\<Object\>는 모든 타입을 허용한다는 의사를 컴파일러에게 명확히 전달한 것이다. 매개변수로 List를 받는 메서드에 List\<String\>을 넘길 수 있지만, List\<Object\>를 받는 메서드에는 넘길 수 없다.

이는 제네릭의 하위 타입 규칙 때문이다. 즉, List\<String\>은 로 타입인 List의 하위 타입이지만, List\<Object\>의 하위 타입이 아니다. 그 결과, **List\<Object\> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안전성을 잃게 된다.**

<br>

## 3. 비한정적 와일드 타입

2개의 집합(Set)을 받아 공통 원소를 반환하는 메서드를 작성한다고 해보자. 

```java
static int numElementsInCommon(Set s1, Set s2) {
  int result = 0;
  for (Object o1 : s1) {
    if (s2.contains(o1))
      result++;
  }
  return result;
}
```

이 메서드는 동작은 하지만 로 타입을 사용해 안전하지 않다. 따라서 비한정적 와일드카드 타입을 대신 사용하는 것이 좋다. 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자. 

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
```

<br>

비한정적 와일드카드 타입인 Set\<?\>와 로 타입인 Set의 차이는 무엇일까?

특징을 간단히 말하자면 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다. 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 Collection\<?\>에는 (null 외에는) 어떤 원소도 넣을 수 없다. 즉, 컬렉션의 타입 불변식을 훼손하지 못하게 막은 것이다. 

구체적으로는 (null 외에는) 어떤 원소도 Collection\<?\>에 넣지 못하게 했으며, 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 했다. 이러한 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드카드 타입을 사용하면 된다. 

<br>

## 4. 로 타입을 써야하는 예외 상황

로 타입을 쓰지 말라는 규칙에도 소소한 예외가 몇 개 있다.

#### 1) class 리터럴에는 로 타입을 써야 한다.

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다(배열과 기본 타입은 허용한다). 예를 들어 List.class, String\[\].class, int.class는 허용하고 List\<String\>.class와 List\<?\>.class는 허용하지 않는다.

#### 2) instanceof의 피연산자로 로 타입을 쓸 수 있다.

런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다. 그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다. 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, 차라리 로 타입을 쓰는 편이 깔끔하다.

```java
if (o instanceof Set) { // 로 타입
  Set<?> s = (Set<?>) o; // 와일드카드 타입
  ...
}
```

<br>

## 5. 핵심 정리

- 로 타입을 사용하면 런타임 예외가 날 수 있으니 사용하면 안 된다.
- 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
- 로 타입은 제네릭 타입 시스템에 속하지 않는다.
- Set\<Object\>와 Set\<?\>는 안전하지만, 로 타입인 Set은 안전하지 않다.

<br>

## 6. Related Posts

* 소거 (Item 28)
* 제네릭 메서드 (Item 30)
* 한정적 와일드카드 타입 (Item 31)

