### 💡 용어정리

- **제너릭 클래스 혹은 제너릭 인터페이스 : **클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 경우

  ex) List 인터페이스는 원소타입을 나타내는 타입 매개변수 E를 받는다 (ex. `List<E>`)

- **제네릭 타입 :** 제네릭 클래스와 제네릭 인터페이스를 통틀어 이르는 말

- **로 타입 :** 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때

<br>

---

<br>

### ⚔ 제너릭 타입 vs 로 타입

제네릭 타입은 일련의 매개변수화 타입을 정의한다 (ex. `List<String>`)

제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다 (ex. `List`)

로 타입은 제네릭이 나오기 전 소스와의 호환성을 위해 제공된다

<br>

**✏ #01 예제소스 | 컬렉션의 로 타입**

```java
private final Collection stamps = ...;
```

> `stamp.add(new Coin(...));` 
>
> 도장(Stamp) 대신 동전(Coin)을 넣어도 아무 오류 업이 컴파일되고 실행된다

<br>**✏ #02 예제소스 | 매개변수화된 컬렉션 타입 - 타입 안전성 확보**

```java
private final Collection<Stamp> stamps = ...;
```

> `stamps`에는 `Stamp`의 인스턴스만 넣어야 함을 컴파일러가 인지
>
> 다른 타입의 인스턴스를 넣으려 하면 컴파일 오류 발생
>
> 컴파일러가 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가

<br>

**로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력은 모두 잃게 된다**

<br>

---

<br>

### ❓ 로 타입을 쓰는 이유

- 자바에서 제네릭 없이 짠 코드가 많아 호환성을 위하여 남아있음
- 마이그레이션 호환성을 위해 로 타입을 지원하고 제네릭 구현에는 소거 방식을 사용하기로 함

<br>

---

<br>

### 📝 매개변수화 타입

**: `List<Object>`처럼 임의 객체를 허용하는 매개변수화 타입**

- 매개변수로 `List`를 받는 메서드에 `List<String>`을 넘길 수 있지만, `List<Object>`를 받는 메서드에는 넘길 수 없음

- 제너릭의 하위 타입 규칙 즉, `List<String>`은 로 타입인 `List`의 하위 타입이지만, `List<Object>`의 하위 타입은 아니다

<br>

**`List`와 차이**

>`List`는 제네릭 타입 자체가 아님
>
>`List<Object>`는 모든 타입을 허용한다는 의사를 컴파일러에게 명확히 전달

<br>

**`List<Object>` 같은 매개변수화 타입을 사용할 때와 달리 `List` 같은 로 타입을 사용하면 타입 안전성을 잃게 된다**

<br>

### 📝 비한정적 와일드카드 타입(unbounded wildcard type)

**: `Set<?>`처럼 어떤 타입이라도 담을 수 있는 범용적인 매개변수화 타입**

- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표를 사용
- 와일드카드 타입은 안전하고, 로 타입은 안전하지 않음
- 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다
- 와일드카드 타입 `Collection<?>` 에는 (`null`외에는) 어떤 원소도 넣을 수 없다

<br>

---

<br>

### 🔎 예외의 경우

**class 리터럴에는 로 타입을 써야 한다**

> - 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다
>
> - `List.class`, `String[].class`, `int.class`는 허용하고 `List<String>.class`와 `List<?>.class`는 허용하지 않는다

<br>

**instanceof 연산자**

>- 런타임에는 제네릭 타입 정보가 지워지므로 `instanceof` 연산자는 비한정적 와일드카드 타입 이외에 매개변수화 타입에는 적용할 수 없다
>
>- 로 타입이든 비한정적 와일드카드 타입이든 `instanceof`는 완전히 똑같이 작동한다
>
>- 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, 차리리 로 타입이 깔끔하다

<br>

---

<br>

### 📌 핵심 정리

**로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다**

**로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다**

**`Set<Object>`는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, `Set<?>`는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다**

**그리고 이들의 로 타입인 `Set`은 제네릭 타입 시스템에 속하지 않는다.**

**`Set<Object>`와 `Set<?>`는 안전하지만, 로 타입인 `Set`은 안전하지 않다**

<br>

---

<br>

### 📚 참고자료

| 한글용어                 | 영문영어                | 예                                  | 아이템        |
| ------------------------ | ----------------------- | ----------------------------------- | ------------- |
| 매개변수화 타입          | parameterized type      | List\<String>                       | 아이템 26     |
| 실제 타입 매개변수       | actual type parameter   | String                              | 아이템 26     |
| 제네릭 타입              | generic type            | List\<E>                            | 아이템 26, 29 |
| 정규 타입 매개변수       | formal type parameter   | E                                   | 아이템 26     |
| 비한정적 와일드카드 타입 | unbounded wildcard type | List<?>                             | 아이템 26     |
| 로 타입                  | raw type                | List                                | 아이템 26     |
| 한정적 타입 매개변수     | bounded type parameter  | \<E extends Number>                 | 아이템 29     |
| 재귀적 타입 한정         | recursive type bound    | <T extends Camparable\<T>>          | 아이템 30     |
| 한정적 화일트카드 타입   | bounded wildcard type   | List<? extends Number>              | 아이템 31     |
| 제네릭 메서드            | generic method          | static \<E> List\<E> as List(E[] a) | 아이템 30     |
| 타입토큰                 | type token              | String.class                        | 아이템 33     |

