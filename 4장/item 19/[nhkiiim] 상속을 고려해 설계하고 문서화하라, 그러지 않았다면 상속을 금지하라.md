# 상속을 고려해 설계하고 문서화하라, 그러지 않았다면 상속을 금지하라

### 1. 상속을 고려한 설계와 문서화
- 메소드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남기기!
- 성속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다!
- 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있음!
- 그때 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해햐해!

- 어떤 수서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야해!
- 재정의 가능 : public과 protected 메서드 중 final이 아닌 모든 메서드!
- 다시 말해서 -> `재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야해!`


#
### 2. @implSpec
- API문서의 메서드 설명 끝에서 종종 "Implementation Requiredments"로 시작하는 절을 볼 수 있음

- 메서드 내부 동작 방식을 설명하는 곳!
- 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성
- 재정의 시 메서드의 동작에 어떻게 영향을 주는지 확실히 알려줌

- 어떻게가 아닌 무엇을 하는지 알려줘야한다!

- 상속이 캡슐화를 하기 때문에 클래스를 안전하게 상속할 수 있또록 하려면 내부 구현방식을 설명해야 함!
- @implSpec 태그는 자바 8에서 처음 도입! 9에서 본격적으로 사용!
- 자바 11에서는 선택사항으로 남아있다

<br>

- 태그 활성화 방법
```
-tag "implSpec:a:Implementation Requirements:"
```

#
### 3. 훅 선별해 protected 메서드로 공개하기
- 내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다!
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면!!!
- 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별해 protected 메서드 형태로 공개해야할 수도 있다!

- 드물게는 protected 필드로 공개해야할 수도 있다!
- 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할까!
- 안타깝지만 마법같은 방법은 없다! 심사숙고 해서 예측하고 시험해보는 것이 방법 ??? 모야
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 `유일!`

- 꼭 필요한 protected 멤버를 놓쳤다면 빈자리가 드러날 것이고, 반대로 전혀 쓰이지 않는다면 private으로 해야할지도!


#
### 4. 널리 쓰일 클래스를 상속용으로 설계하기

- 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정을 영원히 책임져야한다! (무서워)
- 그러니까 꼭 하위 클래스 만들어서 검증 해보자!

<br>

- 상속을 허용하는 클래스가 지켜야할 제약
  - 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능한 메서드를 호출해서는 안된다! (프로그램 오작동)
  - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행돼 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출!
  - 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존하면 -> 의도대로 동작 X

```java
public class Super{
  public Super(){
    overrideMe();
  }
  
  public void overrideMe(){ }
}
```

```java
static class Sub extends Super{
  private final Instant instant;

  Sub(){
    instant = Instant.now();
  }
  
  @Override
  public void overrideMe(){
      System.out.println(instant);
  }
  
  public static void main(String[] args){
    Sub sub = new Sub();
    sub.overrideMe();
  }
```

- instant를 두번 출력하지 않고 null, instant 출력!



#
### 5. Cloneable과 Serializable의 상속 설계
- 상속용 설계를 어렵게 만드는 친구들!

- 둘 중 하나라도 구현한 클래스를 상속하는 것은 좋지 않은 설계!
- clone과 readObject를 모두 재정의 가능 메서드를 호출해서는 안된다~
- Serializable을 구현한 상속용 클래스가 readResolve나 write Replace 메서드를 가지면 private 아닌 proteced로 해주자!

#
### 6. 일반적인 구체 클래스
- 전통적으로 final도 아니고 상속용으로 설계되거나 문서화되지 않음!
- 그대로 두면 위험하기 때문에 상속용으로 설계하지 않은 클래스는 상속을 금지하자!!





