### 📚 문서화

**: 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야한다**

- 호출되는 메서드가 재정의 가능 메서드라면 호출하는 메서드의 API설명에 적시해야 한다

  어떤 순서로 호출하는지 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다

  > *재정의가능이란 `public`과`protected` 메서드 중 `final`이 아닌 모든 메서드*

- API 문서의 메서드 설명 끝에 "Implementation Requirements"로 시작하는 절은 그 메서드의 내부 동작 방식을 설명하는 곳이다

  `implSpec` 태그를 붙여주면 자바독 도구가 생성해준다

  > 자바 8에서 처음 도입된 @ImplSpec 태그를 활성화 하려면 명령줄 매개변수로 `-tag "implSpec:a:Implementation Requirements"` 를 지정해주면 된다

<br>

---

<br>

### 📑 좋은 API 문서란?

**: 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다**

- 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야한다
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 `protected`메서드 형태로 공개해야 할 수도 있다
- `protected` 필드로 공개해야 할 수도 있다

<br>

**어떤 메서드를 `protected`로 노출해야 할까?**

>  심사숙고해서 잘 예측해본 다음, 실제 하위클래스를 만들어 시험해보는 것이 최선이다
>
>  `protected`메서드는 내부 구현에 해당하므로 가능한 적게, 그러나 너무 적어서 상속으로 얻는 이점마저 없어지면 안된다
>
>  상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다

<br>

---

<br>

### 상속용 클래스 설계

**: 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다**

<br>

**✔ 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안 된다**

> 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다
>
> 재정의한 메서드가 하위 클래스의 생성자에서 초기화 하는 값에 의존한다면 오작동을 일으킨다

**✏ #01 예제소스 | 잘못된 예**

```java
public class Super {
    public Super() {
        overrideMe();
    }
    
    public void overrideMe() {
    }
}
```

```java
public final class Sub extends Super {
	// 초기화되지 않은 final 필드. 생성자에서 초기화한다.
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override public void overrideMe() {
		System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

>`instant`를 두 번 출력하는 것을 기대했지만, 첫 번째는 `null`을 출력한다
>
>상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기 전에 `overrideMe`를 호출하기 때문이다
>
>`final` 필드의 상태가 두가지 (하나인게 정상)
>
>`overrideMe`에서 `instant` 객체의 메서드를 호출하려 한다면 상위 클래스의 생성자가 `overrideMe`를 호출할 때 `NullPointException`을 던진다

<br>

**✔ `clone`과 `readObject` 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다**

> `readObejct`의 경우 하위 클래스의 상태가 역직렬화 되기 전에 재정의한 메서드부터 호출한다
>
> `clone`의 역ㅇ우 하위 클래스의 `clone`메서드가 복제본의 상태를 (올바른 상태로) 수정하기 전에 재정의한 메서드를 호출한다

<br>

**✔ Serializable을 구현한 상속용 클래스가 `readResolve`나 `writeReplace` 메서드를 갖는다면 `private`가 아닌 `protected`로 선언해야 한다**

>`private`으로 선언한다면 하위 클래스에서 무시되기 때문이다

<br>

---

<br>

### ❓ 일반적인 구체 클래스라면

**: 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 가장 좋은 방법이다**

<br>

**상속을 금지하는 방법**

>1. 클래스를 `final`로 선언하는 방법 (Easy)
>2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법

<br>

---

<br>

### 📌 핵심정리

**상속용 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 한다**

**문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다**

**그렇지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오작동하게 만들 수 있다**

**다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다**

**클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하는 편이 낫다**

**상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다**

<br>
