### 🔍 디폴트 메서드

**: 자바 8 에서 추가된 인터페이스에 메서드를 추가할 수 있도록하는 메서드**

- 자바 8 이전에 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드 추가 불가
- 디폴트 메서드 선언 시, 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현
- 구현 클래스에 상관없이 무작정 삽입

<br>

---

<br>

### 💡 주의사항

- 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드 작성은 어려움

<br>

**✏ #01 예제소스 | Collection 인터페이스에 추가된 디폴트 메서드**

```java
default boolean removeIf(Predicate<? super E> filter) {
    Object.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext();) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

> 디폴트 구현은 반복자를 이용해 순회하면서 각 원소를 인수로 넣어 프레디키트를 호출
>
> 프레디키트가 `true`를 반환하면 반복자의 `remove`메서드를 호출해 그 원소를 제거

<br>

---

<br>

### 📘 SynchronizedCollection

- 아파치 버전은 (컬렉션 대신) 클라이언트가 제공한 객체로 락을 거는 능력을 후가로 제공
- 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스

<br>

**디폴트 구현 문제점**

- 자바 8 에서 `removeIf`의 디폴트 구현을 물려받는 경우 `removeIf`의 구현은 동기화에 관해 아무것도 모르므로 락 객체를 사용할 수 없다
- `SynchronizedCollection` 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 `removeIf`를 호출하면 `ConcurrentModificationException`이 발생하거나 다른 예기치 못한 결과로 이어짐

<br>

**해결방법**

- 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행
- `Collections.synchronizedCollection`이 반환하는 `package-private` 클래스들은 `removeIf`를 재정의하고, 이를 호출하는 다른 메서드들은 디폴트 구현을 호출하기전에 동기화

<br>

---

<br>

### 📌 핵심정리

> **기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야한다**
>
> **새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 아주 유용하다**
>
> **디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의가 필요하다**
>
> **새로운 인터페이스라면 릴리즈전에 반드시 많은 테스트를 거쳐야한다**
>
> **인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안 된다**

<br>
