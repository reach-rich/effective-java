Effective Java의  49번째 아이템 "매개변수가 유효한지 검사하라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 1. 매개변수 유효성 검사의 필요성

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다. 

반면에 매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 생길 수 있다.

* 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
* 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
* 메서드는 잘 수행되지만 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 수 있다. (실패 원자성에 어긋남)

<br>

## 2. 매개변수의 제약 문서화

public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 보통은 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException 중 하나가 될 것이다.

매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다. 다음은 전형적인 예다.

```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainer 메서드와 다르다.
 * @param m 계수 (양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
  if (m.signum() <= 0) {
    throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
  }
  // 계산 수행
}
```

이 메서드는 m이 null이면 m.signum() 호출 때 NullPointerException을 던진다. 그런데 "m이 null일 때 NullPointerException을 던진다"라는 말은 메서드 설명 어디에도 없다. 그 이유는 이 설명을 BigInteger 클래스 수준에서 기술했기 때문이다. 

클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.

<br>

때로는 계산 과정에서 유효성 검사가 이뤄지지만 실해했을 때 잘못된 예외를 던지기도 한다. 달리 말하면, 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.

이런 경우에는 예외 번역(exception translate) 관용구를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다.

<br>

## 3. 매개변수 유효성 검사 방법

자바 7에 추가된 **java.util.Objects.requireNonNull** 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다. 원하는 예외 메시지도 지정할 수 있다. 또한 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

<br>

자바 9에서는 Objects에 **범위 검사 기능**도 더해졌다. checkFromIndexSize, checkFromToIndex, checkIndex라는 메서드들인데, null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고, 리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위는 다루지 못한다. 그래도 이런 제약이 걸림돌이 되지 않는 상황에서는 아주 유용하고 편하다.

<br>

공개되지 않은 메서드라면 패키지 제작자가 메서드가 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 우리가 보증할 수 있고, 그렇게 해야 한다. 다시 말해 public이 아닌 메서드라면 **단언문(assert)**을 사용해 매개변수 유효성을 검증할 수 있다. 예를 살펴보자.

```java
private static void sort(long a[], int offset, int length) {
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
  ... // 계산 수행
}
```

여기서 핵심은 이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다. 

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다. 

* 실패하면 AssertionError를 던진다.
* 런타임에 아무런 효과도, 아무런 성능 저하도 없다.
  * 단, java를 실행할 때 명령줄에서 -ea 혹은 --enableassertions 플래그 설정하면 런타임에 영향을 준다.

<br>

## 4. 주의할 점

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야 한다. 

예를 들어 List를 반환하는 메서드가 있다고 하자. 이 메서드에서 List가 null인지를 검사하지 않는다면, 메서드를 사용하는 클라이언트에서 List를 사용하려고 할때 비로소 NullPointException이 발생한다. 이때가 되면 이 List를 어디서 가져왔는지 추적하기 어려워 디버깅이 상당히 괴로워질 수 있다.

생성자는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다. 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

<br>

매개변수의 유효성을 검사해야 한다는 규칙에도 예외는 있다.

* 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때
* 계산 과정에서 암묵적으로 검사가 수행될 때
  * 하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있다.

<br>

## 5. 핵심 정리

* 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.
* 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다.

