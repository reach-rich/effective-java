Effective Java의  43번째 아이템 "람다보다는 메서드 참조를 사용하라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 1. 메서드 참조

람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징은 간결함이다. 그런데 자바에는 함수 객체를 심지어 람다보다도 더 간결하게 만드는 방법이 있다. 바로 **메서드 참조(method reference)**다. 

다음 코드는 임의의 키와 Integer 값의 매핑을 관리하는 프로그램의 일부다. 이때 값이 키의 인스턴스 개수로 해석된다면, 이 프로그램은 멀티셋(multiset)을 구현한 게 된다. 

```java
map.merge(key, 1, (count, incr) -> count + incr);
```

merge 메서드는 키, 값, 함수를 인수로 받으며, 주어진 키가 맵 안에 아직 없다면 주어딘 {키, 값} 쌍을 그대로 저장한다. 반대로 키가 이미 있다면 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어쓴다. 즉, 맵에 {키, 함수의 결과} 쌍을 저장한다. 

깔끔해 보이는 코드지만 아직도 거추장스러운 부분이 남아 있다. 세 번째 인수의 함수(람다)는 두 인수의 합을 단순히 반환하기만 한다. 자바 8이 되면서 Integer 클래스(와 모든 기본 타입의 박싱 타입)는 이 람다와 기능이 같은 정적 메서드 sum을 제공하기 시작했다. 따라서 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 더 보기 좋게 얻을 수 있다.

```java
map.merge(key, 1, Integer::sum);
```

그런데 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다. 이런 람다는 길이가 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.

<br>

### 메서드 참조의 5가지 유형

1. 정적 메서드 참조

   ```java
   // 메서드 참조
   Integer::parseInt
     
   // 람다
   str -> Integer.parseInt(str)
   ```

2. 한정적 인스턴스 메서드 참조

   ```java
   // 메서드 참조
   Instant.now()::isAfter
   
   // 람다
   Instant then = Instant.now();
   t -> then.isAfter(t)
   ```

3. 비한정적 인스턴스 메서드 참조

   ```java
   // 메서드 참조
   String::toLowerCase
     
   // 람다
   str -> str.toLowerCase()
   ```

4. 클래스 생성자 메서드 참조

   ```java
   // 메서드 참조
   ThreeMap<K, V>::new
   
   // 람다
   () -> new TreeMap<K, V>()
   ```

5. 배열 생성자 메서드 참조

   ```java
   // 메서드 참조
   int[]::new
   
   // 람다
   len -> new int[len]
   ```

<br>

## 2. 핵심 정리

* 메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 
* 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.

<br>

## 3. Relates Post

* 스트림 (Item 45)
