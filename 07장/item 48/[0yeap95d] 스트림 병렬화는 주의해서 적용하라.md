### 🔎 스트림 병렬화

- 자바로 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 노력해야함
- 병렬 스트림 파이프라인 프로그래밍도 같음

<br>

**✏ #01 예제소스 | 스트림을 사용해 처음 20개의 메르센 소수를 생성하는 프로그램**

```java
public static void main(String[] args) {
    primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(System.out::println);
}

static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

>프로그램을 실행하면 즉각 소수를 찍기 시작해서 12.5초 만에 완료
>
>속도를 높이기 위해 스트림 파이프라인의 `parallel()`을 호출하면 아무것도 출력하지 못하고 CPU를 90% 잡아먹는 상태가 무한히 계속됨
>
>스트림 라이브러리가 파이프라인을 병렬화하는 방법을 찾아내지 못했기 때문

<br>

**✔ 데이터 소스가 `Stream.iterate`거나 중간 연산으로 `limit`를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없음**

- 파이프라인 병렬화는 `limit`를 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 판단
- 위 코드는 새롭게 메르센 소수를 찾을 때마다 그 전 소수를 찾을 때보다 두 배 정도 더 오래 걸림

<br>

**📌 스트림 파이프라인을 마구잡이로 병렬화하면 오히려 성능이 훨씬 더 나빠질 수 있음**

<br>

---

<br>

### 📚 효율적인 스트림 병렬화

**1️⃣ 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스거나 배열, `int` 범위, `long` 범위일 때 병렬화의 효과가 가장 좋음**

> 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기 좋음
>
> 나누는 작업은 `Spliterator`가 담당하며, `Spliterator` 객체는 `Stream`이나 `Iterable`의 `spliterator`메서드로 얻어올 수 있음 
>
> 순차적으로 실행할 때 참조 지역성이 뛰어남
>
> - 참조지역성이 가장 뛰어난 자료구조는 기본타입의 배열
> - 기본 타입의 배열은 데이터 자체가 메모리에 연속해서 저장되어 있음

<br>

**2️⃣ 스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 줌**

> 종단 연산 중 병렬화에 가장 적합한 것은 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업인 **축소**
>
> `Stream`의 `reduce` 메서드 중 하나, 혹은 `min`, `max`, `count`, `sum` 같이 완성된 형태로 제공되는 메서드 중 하나를 선택해 수행
>
> `anyMatch`, `allMatch`, `noneMatch` 처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합
>
> 반명 가변 축소를 수행하는 `Stream`의 `collect` 메서드는 병렬화에 적합하지 않음

<br>

**3️⃣ 스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있음**

> 결과가 잘못되거나 오작동하는 것은 **안전 실패**라고 한다
>
> 안전실패는 병렬화한 파이프라인이 사용하는 `mappers`, `filters`, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있음
>
> `Stream` 명세는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의
>
> - 예컨대 `Stream`의 `reduce` 연산에 건네지는 `accumulater`(누적기)와 `combiner`(결합기) 함수는 반드시 결합법칙을 만족하고, 간섭받지 않고, 상태를 갖지 않아야 함

<br>

**4️⃣ 스트림 병렬화 정렬**

> 위의 메르센 소수는 완료되더라도 순서가 올바르지 않을 수 있음
>
> 출력 순서를 순차 버전처럼 정렬하고 싶다면 종단 연산 `forEach`를 `forEachOrdered`로 바꿔주면 됨

<br>

**5️⃣ 성능이 향상될지 추정하는 간단한 방법**

> 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱하기
>
> 이 값이 최소 수십만은 되어야 성능 향상을 기대할 수 있음

<br>

**6️⃣ 스트림 병렬화는 오직 성능 최적화 수단**

> 변경 전후로 성능을 테스트하여 사용할 가치가 있는지 판단
>
> 운영 시스템과 흡사한 환경에서 테스트
>
> 보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로, 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에 악영향을 줄 수 있음을 유념

<br>

**✔ 스트림 병렬화가 효과를 보는 경우 많지 않지만, 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있음**

<br>

---

<br>

### 📖 스트림 파이프라인 병렬화의 옳은 예

**✏ #02 예제소스 | 소스 계산 스트림 파이프라인 - 병렬화에 적합**

```java
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
        .mapToObj(BigInteger::valueOf)
        .filter(i -> i.isProbablePrime(50))
        .count();
}
```

> 실행시간 31s

<br>

**✏ #03 예제소스 | 소수 계산 스트림 파이프라인 - 병렬화 버전**

```java
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
        .parallel()
        .mapToObj(BigInteger::valueOf)
        .filter(i -> i.isProbablePrime(50))
        .count();
}
```

>실행시간 9.2s

*n이 크다면 레머의 공식이라는 효율적인 알고리즘이 존재*

<br>

---

<br>

### 🔎 SplittableRandom

- 무작위 수들로 이뤄진 스트림을 병렬화할 때에는 `ThreadLocalRandom` 보다는 `SplittableRandom`을 사용할 것
- `SplittableRandom`은 정확히 이런 곳에 쓰고자 설계된 것으로 병렬화하면 성능이 선형으로 증가
- `ThreadLocalRandom`은 단일 쓰레드에 쓰고자 설계
- 그냥 `Random`은 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능

<br>

---

<br>

### 📌 핵심정리

**계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라**

**스트림을 잘못 병렬화하면 프로그램을 오작동하게 하거나 성능을 급격히 떨어뜨린다**

**병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라**

**그래서 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때, 오직 그럴 때만 병렬화 버전코드를 운영 코드에 반영하라**
