# 인스턴스화를 막으려거든 private 생성자를 사용하라

### 1. 정적인 친구들만 가진 클래스?
- 단순하게 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을거야!

- 객체지향적으로 사고하는 멋쟁이로서는 곱게 보이진 않아 

- 하지만 쓰임새가 있긴 하겠지 ^-^
#

### 2. 그런 예시들
- ex) java.lang.Math 나 java.util.Collections 처럼 득정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드를 모아놓을지도?
  - 자바8부터는 이런 메서드들 인터페이스에 넣을 수 있음

- ex) final 클래스와 관련 메서드를 모아둘 때도 쓰긴 함
  - final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문!
 ###
      final 붙으면 오버라이드 불가능 : https://opentutorials.org/course/62/15767
      
#
### 3. 암튼 걔네는 인스턴스를 만들어 쓰자는 건 아냐
- 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계하는게 아냐!

- BUT 생성자를 시하지 않으면 컴파일러가 기본 생성자를 만들어 주지
- 매개변수를 받지 않는 public 생성자가 만들어 지는거지 like public Car(){}
- 사용자는 그게 뭔지 구분 못해 (자동으로 만들어 졌는지 아닌지)
- 공개 API들에서도 의도치 않게 인스턴스화할 수 있게 된 클래스들이 종종 있더라~

#

### 4. 추상 클래스로 만들었다면?
- 인스턴스화를 막을 수 없어
- 
- 하위 클래스를 만들어서 인스턴스화하면 그만이니까~
- 사용자는 상속해서 쓰라고 오해할 수도 있지 (더 큰 문제라고~)

<br>

__다행히! 인스턴스화를 막는건 어렵지 않지__

#
### 5. 그래서 인스턴스화를 막는 법
- 컴파일러가 기본 생성자를 못만들게 private 생성자를 추가하자

 ```java
 private UtilityClass(){
 //기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용)
  throw new AssertionError();
 }
 ```
 
 - 명시적 생성자가 private니까 클래스 밖에선 접근할 수 없지롱
 
 - 꼭 에러를 던질 필요는 없지만 혹쉬나 해서 추가해줌
 - 이 코드는 어떤 환경에서도 클래스가 인스턴스화 되는 걸 막아줘
 - 상속을 불가능하게 하는 효과도있지 (접근을 막으니까)
 
 <br>
 
 __근데 왜 생성자 있으면서 못쓰게함? 할 수도 있으니 친철한 주석을 꼭 달자!__
 
 > //기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용)__
 
 
 #
 
 ### 6. 결론
 
 정적 멤버만 넣어둔 클래스를 굳이 꼭 필요해서 만들거면 인스턴스를 만들 용도는 아니니까 
 
 인스턴스에 기본 생성자가 생기지 않도록 private 생성자를 꼭 명시적으로 적어두고 
 
 혹쉬 모르니까 에러도 던져주고 
 
 다른 개발자가 생성자 만들어두고 쓰지 말라는 건 뭐야? 할 수도 있으니까 주석도 친절하게 달아주라~!!
 
 
 
